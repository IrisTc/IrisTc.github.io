(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{194:function(t,a,n){"use strict";n.r(a);var e=n(6),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"算法复习提纲"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法复习提纲"}},[t._v("#")]),t._v(" 算法复习提纲")]),t._v(" "),n("h2",{attrs:{id:"数学基础知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数学基础知识"}},[t._v("#")]),t._v(" 数学基础知识")]),t._v(" "),n("h3",{attrs:{id:"函数的增长"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数的增长"}},[t._v("#")]),t._v(" 函数的增长")]),t._v(" "),n("ul",[n("li",[t._v("渐进记号的数学含义\n"),n("ul",[n("li",[t._v("渐进确界 theta")]),t._v(" "),n("li",[t._v("渐进上界O")]),t._v(" "),n("li",[t._v("渐进下界 欧米伽")])])])]),t._v(" "),n("h3",{attrs:{id:"递归式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#递归式"}},[t._v("#")]),t._v(" 递归式")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("代换法")])]),t._v(" "),n("li",[n("p",[t._v("递归树法")])])]),t._v(" "),n("h2",{attrs:{id:"算法设计技术"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法设计技术"}},[t._v("#")]),t._v(" 算法设计技术")]),t._v(" "),n("h3",{attrs:{id:"分治法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分治法"}},[t._v("#")]),t._v(" 分治法")]),t._v(" "),n("h4",{attrs:{id:"每层递归上有三个步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#每层递归上有三个步骤"}},[t._v("#")]),t._v(" 每层递归上有三个步骤")]),t._v(" "),n("ul",[n("li",[t._v("分解：将原问题分解成一系列子问题")]),t._v(" "),n("li",[t._v("解决：递归解各子问题，若子问题足够小则直接求解")]),t._v(" "),n("li",[t._v("合并：将子问题的结果合并成原问题")])]),t._v(" "),n("h4",{attrs:{id:"合并排序merge-sort"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合并排序merge-sort"}},[t._v("#")]),t._v(" 合并排序merge sort")]),t._v(" "),n("ul",[n("li",[t._v("分解：将n个元素分成各含n/2个元素的子序列")]),t._v(" "),n("li",[t._v("解决：用合并排序法对两个子序列递归排序")]),t._v(" "),n("li",[t._v("合并：合并两个已排序的子序列以得到排序结果")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("merge-sort(A,p,r)\nif p<r\n\tthen q = (p+r)/2\n\t\t merge-sort(A,p,q)\n\t\t merge-sort(A,q+1,r)\n\t\t merge(A,p,q,r)\n\t\t \nmerge(A,p,q,r)\nn1 = q-p+1\nn2 = r-q\ncreate arrays L[1..n1+1] and R[1..n2+1]\nfor i=1 to n1\n\tdo L[i] = A[p+i-1]\nfor j=1 to n2\n\tdo R[j] = A[q+j]\nL[n1+1] = 正无穷\nR[n2+1] = 正无穷\ni = 1\nj = 1\nfor k=p to r\n\tdo if L[i]<=R[j]\n\t\tthen A[k]=L[i]\n\t\t\t i=i+1\n\t\telse A[k]=R[j]\n\t\t\t j=j+1\n")])])]),n("h3",{attrs:{id:"动态规划"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[t._v("#")]),t._v(" 动态规划")]),t._v(" "),n("p",[t._v("分治法会重复解相同的子问题，而动态规划对每一子问题只做一次计算，将答案存储在一张表中，故可避免重复计算")]),t._v(" "),n("h4",{attrs:{id:"四个步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四个步骤"}},[t._v("#")]),t._v(" 四个步骤")]),t._v(" "),n("ul",[n("li",[t._v("描述最优解的结构特征")]),t._v(" "),n("li",[t._v("递归地定义一个最优解的值")]),t._v(" "),n("li",[t._v("自底向上计算一个最优解的值")]),t._v(" "),n("li",[t._v("从已计算的信息中构造一个最优解")])]),t._v(" "),n("h4",{attrs:{id:"装配线调度问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#装配线调度问题"}},[t._v("#")]),t._v(" 装配线调度问题")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("递归公式")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("fastest-way(a,t,e,x,n)\n\nf1[1]=e1+a1,1\nf2[1]=e2+a2,1\nfor j=2 to n\n\tdo if f1[j-1]+a1,j<=f2[j-1]+t2,j-1+a1,j\n\t\t\tthen f1[j]=f1[j-1]+a1,j\n\t\t\t \tl1[j]=1\n\t\t\telse f1[j]=f2[j-1]+t2,j-1+a1,j\n\t\t\t \tl1[j]=2\n\t\tif f2[j-1]+a2,j<=f1[j-1]+t1,j-1+a2,j\n\t\t\tthen f2[j]=f2[j-1]+a2,j\n\t\t\t\t l2[j]=2\n\t\t\telse f2[j]=f1[j-1]+t1,j-1+a2,j\n\t\t\t\t l2[j]=1\nif f1[n]+x1<=f2[n]+x2\n\tthen f*=f1[n]+x1\n\t\t l*=1\n\telse f*=f2[n]+x2\n\t\t l*=2\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('print-stations(l,l*,n)\n\ni=l*\nprint "line" i "station" n\nfor j=n downto 2\n\tdo i=li[j]\n\t\tprint "line" i "station" j-1\n')])])])])]),t._v(" "),n("h4",{attrs:{id:"矩阵链乘问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#矩阵链乘问题"}},[t._v("#")]),t._v(" 矩阵链乘问题")]),t._v(" "),n("h4",{attrs:{id:"最长公共子序列问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#最长公共子序列问题"}},[t._v("#")]),t._v(" 最长公共子序列问题")]),t._v(" "),n("h3",{attrs:{id:"贪心法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#贪心法"}},[t._v("#")]),t._v(" 贪心法")]),t._v(" "),n("h4",{attrs:{id:"设计步骤"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#设计步骤"}},[t._v("#")]),t._v(" 设计步骤")]),t._v(" "),n("ul",[n("li",[t._v("将优化问题分解为做出一种选择及留下一个待解的子问题")]),t._v(" "),n("li",[t._v("证明对于原问题总是存在一个最优解会做出贪心选择，从而保证贪心选择是安全的")]),t._v(" "),n("li",[t._v("验证当做出贪心选择后，它和剩余的一个子问题的最优解组合在一起，构成了原问题的最优解")])]),t._v(" "),n("h4",{attrs:{id:"活动选择问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#活动选择问题"}},[t._v("#")]),t._v(" 活动选择问题")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("GreedyActivitySelector(S,f){\n\tn = length[S]\n\tA = {a1}\n\ti = l\n\tfor m=2 to n do\n\t\tif(fi<=Sm) then {\n\t\t\tA = A并{am}\n\t\t\ti = m\n\t\t}\n\treturn A\n}\n")])])]),n("h4",{attrs:{id:"哈夫曼编码问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈夫曼编码问题"}},[t._v("#")]),t._v(" 哈夫曼编码问题")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Huffman()\n\tn = |C|\n\tQ = C\n\tfor i = 1 to n-1\n\t\tdo allocate a new n ode z\n\t\t\tleft-son[z] = x = extract-min(Q)\n\t\t\tright-son[z] = y = extract-min(Q)\n\t\t\tf[z] = f[x] + f[y]\n\t\t\tInsert(Q, z)\n\treturn extract-min(Q)\n")])])]),n("h3",{attrs:{id:"排序问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#排序问题"}},[t._v("#")]),t._v(" 排序问题")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("插入排序、合并排序")])]),t._v(" "),n("li",[n("p",[t._v("快速排序")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("分治算法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("partition(A,p,r)\n\nx=A[r]\ni=p-1\nfor j=p to r-1\n\tdo if A[j]<=x\n\t\tthen i=i+1\n\t\t\t exchange A[i]--A[j]\nexchange a[i+1]-A[r]\nreturn i+1\n\nquicksort(A,p,r)\n\nif p<r\n\tthen q=partition(A,p,r)\n\t\t quicksort(A,p,q-1)\n\t\t quicksort(A,q+1,r)\n")])])])])])]),t._v(" "),n("li",[n("p",[t._v("堆排序")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("max-heapify(A,i)\n\nl=left(i)\nr=right(i)\nif l<=heap-size[A] and A[l]>A[i]\n\tthen largest=l\n\telse largest=i\nif r<=heap-size[A] and A[r]>A[largest]\n\tthen largest=r\nif largest != i\n\tthen exchange A[i]-A[largest]\n\t\t max-heapify(A,largest)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//建堆\nbuild-heapify(A)\n\nheap-size[A]=length[A]\nfor i=length[A]/2 downto 1\n\tdo max-heapify(A,i)\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//堆排序算法\nheapsort(A)\n\nbuild-max-heapify(A)\nfor i=length[A] downto 2\n\tdo exchange A[1]-A[i]\n\t   heap-size[A]=heap-sizep[A]-1\n\t   max-heapify(A,1)\n")])])])]),t._v(" "),n("li",[n("p",[t._v("线性时间排序（不考）")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("计数排序")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Count-Sort(A, B, k)\n\tfor i=0 to k\n\t\tdo C[i] = 0\n\tfor j=1 to length[A]\n\t\tdo C[A[j]] = C[A[j]] + 1\n\tfor i=1 to k\n\t\tdo C[i] = C[i] + C[i-1]\n\tfor j=length[A] downto 1\n\t\tdo B[C[A[j]]] = A[j]\n\t\t   C[A[j]] = C[A[j]] - 1\n")])])])]),t._v(" "),n("li",[n("p",[t._v("基数排序")])]),t._v(" "),n("li",[n("p",[t._v("桶排序")])])])])]),t._v(" "),n("h3",{attrs:{id:"最短路径问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#最短路径问题"}},[t._v("#")]),t._v(" 最短路径问题")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("Bellaman-Ford算法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Bellaman-Ford(G, w, s)\n\tInitialize-Single-Source(G,s)\n\tfor i=1 to |V[G]|-1\n\t\tdo for each edge(u,v)属于E[G]\n\t\t\tdo RELAX(u,v,w)\n\tfor each edge(u,v)属于E[G]\n\t\tdo if d[v] > d[u]+w(u,v)\n\t\t\tthen return FALSE\n\treturn TRUE\n\t\nInitialize-Single-Source(G,s)(G, s)\n\tfor each vertex v属于V[G]\n\t\tdo d[v]=正无穷\n\t\t\tpi[v]=NIL\n\td[s]=0\n\t\nRELAX(u, v, w)\n\tif d[v] > d[u]+w(u,v)\n\t\tthen d[v] = d[u]+w(u,v)\n\t\t\tpi[v] = u\n")])])])]),t._v(" "),n("li",[n("p",[t._v("有向无回路图中的单源最短路径算法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Dag-Shortest-Paths(G, w, s)\n\ttopoligically sort the vertices of G\n\tInitialize-Single-Source(G,s)\n\tfor each vertex u, taken in topologically sorted order\n\t\tdo for each vertex v属于Adj[u]\n\t\t\tdo RELAX(u,v,w)\n")])])])]),t._v(" "),n("li",[n("p",[t._v("Dijkstra算法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Dijkstra(G, w, s)\n\tInitialize-Single-Source(G,s)\n\tS = 空\n\tQ = V[G]\n\twhile Q!=空\n\t\tdo u = EXTRACT-MIN(Q)\n\t\t\tS = S并{u}\n\t\t\tfor each vertex v属于Adj[u]\n\t\t\t\tdo RELAX(u,v,w)\n")])])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);